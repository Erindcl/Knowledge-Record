
npm  是一个NodeJS包管理和分发工具
Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架
引入vue  <script src="https://unpkg.com/vue"></script>
		 <script src="vue.js"></script>

第一个实例：（文本插值方式调用）
	<div id="app">
	  {{ message }}
	</div>

	var vm = new Vue({
	  el: '#app',
	  data: {
	    message: 'Hello Vue!'
	  }
	})
v-if 条件
	<div id="app-3">
	  <p v-if="seen">现在你看到我了</p>
	</div>

	var app3 = new Vue({
	  el: '#app-3',
	  data: {
	    seen: true
	  }
	})
v-for 循环
	<div id="app-4">
	  <ol>
	    <li v-for="todo in todos">
	      {{ todo.text }}
	    </li>
	  </ol>
	</div>

	var app4 = new Vue({
	  el: '#app-4',
	  data: {
	    todos: [
	      { text: '学习 JavaScript' },
	      { text: '学习 Vue' },
	      { text: '整个牛项目' }
	    ]
	  }
	})
v-on 指令绑定一个事件监听器
	<div id="app-5">
	  <p>{{ message }}</p>
	  <button v-on:click="reverseMessage">逆转消息</button>
	</div>

	var app5 = new Vue({
	  el: '#app-5',
	  data: {
	    message: 'Hello Vue.js!'
	  },
	  methods: {
	    reverseMessage: function () {
	      this.message = this.message.split('').reverse().join('')
	    }
	  }
	})
v-model 实现表单输入和应用状态之间的双向绑定
	<div id="app-6">
	  <p>{{ message }}</p>
	  <input v-model="message">
	</div>

	var app6 = new Vue({
	  el: '#app-6',
	  data: {
	    message: 'Hello Vue!'
	  }
	})
v-bind指令被用来响应地更新HTML属性
	
	<a v-bind:href="url"></a>

属性与方法都有前缀 $,以便与代理的 data 属性区分
	
	vm.$el === document.getElementById('example') // -> true

生命周期钩子
	created 这个钩子在实例被创建之后被调用：
		var vm = new Vue({
		  data: {
		    a: 1
		  },
		  created: function () {
		    // `this` 指向 vm 实例
		    console.log('a is: ' + this.a)
		  }
		})
		// -> "a is: 1"
	其它的钩子，在实例生命周期的不同阶段调用，如 mounted、updated、destroyed。
	钩子的 this 指向调用它的 Vue 实例。

数据绑定
	“Mustache” 语法（双大括号）的文本插值：
		<span>Message: {{ msg }}</span>
		注：绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。
	v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。
		<span v-once>This will never change: {{ msg }}</span>
	v-html 指令 输出真正的 HTML 
		<div v-html="rawHtml"></div>
	Mustache 不能在  HTML 属性  中使用，应使用 v-bind 指令：
		<div v-bind:id="dynamicId"></div>

修饰符
	修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定
	.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()(通知 Web 浏览器不要执行与事件关联的默认动作)：
		<form v-on:submit.prevent="onSubmit"></form>

过滤器
	被用作一些常见的文本格式化，目的就是用于文本转换
	过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。
	过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示：
		{{ message | capitalize }}
		<div v-bind:id="rawId | formatId"></div>
		注：过滤器函数总接受表达式的值作为第一个参数。
		new Vue({
		  // ...
		  filters: {
		    capitalize: function (value) {
		      if (!value) return ''
		      value = value.toString()
		      return value.charAt(0).toUpperCase() + value.slice(1)
		    }
		  }
		})
		可串联
		{{ message | filterA | filterB }}
		可调用参数
		{{ message | filterA('arg1', arg2) }}
		注：'arg1' 将传给过滤器作为第二个参数，arg2表达式的值将被求值然后传给过滤器作为第三个参数。

v-bind 缩写  ：
v-on 缩写  @

计算属性
	<div id="example">
	  <p>Original message: "{{ message }}"</p>
	  <p>Computed reversed message: "{{ reversedMessage }}"</p>
	</div>

	var vm = new Vue({
	  el: '#example',
	  data: {
	    message: 'Hello'
	  },
	  computed: {
	    // a computed getter
	    reversedMessage: function () {
	      // `this` points to the vm instance
	      return this.message.split('').reverse().join('')
	    }
	  }
	})
	注：reversedMessage是一个计算属性，它的值依赖于message，是其的一个表达式的值作为一个新的属性使用，两者是同步变化的
	将同一函数定义为一个 method调用表达式中的 method 来可达到同样的效果
		methods: {
		  reversedMessage: function () {
		    return this.message.split('').reverse().join('')
		  }
		}
	计算属性只有在它的相关依赖发生改变时才会重新求值。
	只要发生重新渲染，method 调用总会执行该函数。
	观察和响应 Vue 实例上的数据变动：watch 属性
	 	<div id="demo">{{ fullName }}</div>

		var vm = new Vue({
		  el: '#demo',
		  data: {
		    firstName: 'Foo',
		    lastName: 'Bar',
		    fullName: 'Foo Bar'
		  },
		  watch: {
		    firstName: function (val) {
		      this.fullName = val + ' ' + this.lastName
		    },
		    lastName: function (val) {
		      this.fullName = this.firstName + ' ' + val
		    }
		  }
		})
	computed 属性的版本
		var vm = new Vue({
		  el: '#demo',
		  data: {
		    firstName: 'Foo',
		    lastName: 'Bar'
		  },
		  computed: {
		    fullName: function () {
		      return this.firstName + ' ' + this.lastName
		    }
		  }
		})
	计算属性的setter和getter
		computed: {
		  fullName: {
		    // getter
		    get: function () {
		      return this.firstName + ' ' + this.lastName
		    },
		    // setter
		    set: function (newValue) {
		      var names = newValue.split(' ')
		      this.firstName = names[0]
		      this.lastName = names[names.length - 1]
		    }
		  }
		}
		注：运行 vm.fullName = 'John Doe' 时， setter 会被调用

Class 与 Style 绑定
	对象语法
		<div class="static"
		     v-bind:class="{ active: isActive, 'text-danger': hasError }">
		</div>
		如下 data:
		data: {
		  isActive: true,
		  hasError: false
		}
		渲染为:
		<div class="static active"></div>

		直接绑定数据里的一个对象：
			<div v-bind:class="classObject"></div>

			data: {
			  classObject: {
			    active: true,
			    'text-danger': false
			  }
			}
		绑定返回对象的计算属性:
			<div v-bind:class="classObject"></div>

			data: {
			  isActive: true,
			  error: null
			},
			computed: {
			  classObject: function () {
			    return {
			      active: this.isActive && !this.error,
			      'text-danger': this.error && this.error.type === 'fatal',
			    }
			  }
			}
	数组语法
		<div v-bind:class="[activeClass, errorClass]">

		data: {
		  activeClass: 'active',
		  errorClass: 'text-danger'
		}

		渲染为:
		<div class="active text-danger"></div>

		根据条件切换列表中的 class ，可以用三元表达式：
			<div v-bind:class="[isActive ? activeClass : '', errorClass]">
		多个条件 class 时
			<div v-bind:class="[{ active: isActive }, errorClass]">
	用在组件上
		声明了这个组件:(类将被添加到根元素上面)
		Vue.component('my-component', {
		  template: '<p class="foo bar">Hi</p>'
		})
		然后在使用它的时候添加一些 class：
		<my-component class="baz boo"></my-component>
		HTML 最终将被渲染成为:
		<p class="foo bar baz boo">Hi</p>
	绑定内联样式_对象语法
		v-bind:style
		CSS 属性名可以用驼峰式 (camelCase) 或 (配合引号的) 短横分隔命名 (kebab-case)：
		<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

		data: {
		  activeColor: 'red',
		  fontSize: 30
		}
		直接绑定到一个样式对象通常更好，让模板更清晰：
			<div v-bind:style="styleObject"></div>

			data: {
			  styleObject: {
			    color: 'red',
			    fontSize: '13px'
			  }
			}
	绑定内联样式_数组语法
		<div v-bind:style="[baseStyles, overridingStyles]">
	提供多个带前缀的值：
		<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"

条件渲染
	<h1 v-if="ok">Yes</h1>
	<h1 v-else>No</h1>
	在 <template> 中配合 v-if 条件渲染一整组
		切换多个元素，把一个 <template> 元素当做包装元素，并在上面使用 v-if。最终的渲染结果不会包含 <template> 元素。
		<template v-if="ok">
		  <h1>Title</h1>
		  <p>Paragraph 1</p>
		  <p>Paragraph 2</p>
		</template>
	v-else 元素必须紧跟在 v-if 或者 v-else-if 元素的后面——否则它将不会被识别。
	v-else-if
		可以链式地使用多次：
		<div v-if="type === 'A'">
		  A
		</div>
		<div v-else-if="type === 'B'">
		  B
		</div>
		<div v-else-if="type === 'C'">
		  C
		</div>
		<div v-else>
		  Not A/B/C
		</div>
		类似于 v-else，v-else-if 必须紧跟在 v-if 或者 v-else-if 元素之后。
	声明“这两个元素是完全独立的——不要复用它们”。只需添加一个具有唯一值的 key 属性即可：
		<template v-if="loginType === 'username'">
		  <label>Username</label>
		  <input placeholder="Enter your username" key="username-input">
		</template>
		<template v-else>
		  <label>Email</label>
		  <input placeholder="Enter your email address" key="email-input">
		</template>
		现在，每次切换时，输入框都将被重新渲染。
	v-show 指令 根据条件展示元素的选项，简单地切换元素的 CSS 属性 display 。
	 	<h1 v-show="ok">Hello!</h1>

	如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。

	当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。

列表渲染
	v-for 还支持一个可选的第二个参数为当前项的索引。
		<ul id="example-2">
		  <li v-for="(item, index) in items">
		    {{ parentMessage }} - {{ index }} - {{ item.message }}
		  </li>
		</ul>

		var example2 = new Vue({
		  el: '#example-2',
		  data: {
		    parentMessage: 'Parent',
		    items: [
		      { message: 'Foo' },
		      { message: 'Bar' }
		    ]
		  }
		})
		注：of 可替代 in           
		<div v-for="item of items"></div>
	带有 v-for 的 <template> 标签来渲染多个元素块
		<ul>
		  <template v-for="item in items">
		    <li>{{ item.msg }}</li>
		    <li class="divider"></li>
		  </template>
		</ul>
	通过一个对象的属性来迭代
		<ul id="repeat-object" class="demo">
		  <li v-for="value in object">
		    {{ value }}
		  </li>
		</ul>
		new Vue({
		  el: '#repeat-object',
		  data: {
		    object: {
		      firstName: 'John',
		      lastName: 'Doe',
		      age: 30
		    }
		  }
		})

	<div v-for="(value, key, index) in object">
	  {{ index }}. {{ key }} : {{ value }}
	</div>
	注：index：索引；key：键名
	
	整数迭代
		<div>
		  <span v-for="n in 10">{{ n }} </span>
		</div>

	v-for with v-if
		同一节点， v-for 的优先级比 v-if 更高， v-if 将分别重复运行于每个 v-for 循环中
			<li v-for="todo in todos" v-if="!todo.isComplete">
			  {{ todo }}
			</li>
		有条件地跳过循环的执行
			那么将 v-if 置于包装元素 (或 <template>)上。如:
			<ul v-if="shouldRenderTodos">
			  <li v-for="todo in todos">
			    {{ todo }}
			  </li>
			</ul>
	
	变异方法(会改变被这些方法调用的原始数组)（增删改等）
		push()//在结尾增加一条或多条数据
		pop()//删除最后一条数据
		shift()//删除第一条数据，并返回这条数据
		unshift()//在开始增加一条或多条数据，并返回数组长度
		splice()//向/从数组中添加/删除项目，然后返回被删除的项目。
		sort()//对数组的元素进行排序。
		reverse()//颠倒数组中元素的顺序。
		items 数组调用变异方法：example1.items.push({ message: 'Baz' }) 
	非变异(non-mutating method)方法
		filter()//返回条件为真的数据
		concat()//连接两个或多个数组
		slice()//从已有的数组中返回选定的元素。
		这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：
		example1.items = example1.items.filter(function (item) {
		  return item.message.match(/Foo/)
		})
	注意事项（ 使Vue 能检测以下变动的数组）
		利用索引直接设置一个项
			Vue.set(example1.items, indexOfItem, newValue)
			example1.items.splice(indexOfItem, 1, newValue)
		修改数组的长度
			example1.items.splice(newLength)
	显示过滤/排序结果（不实际改变或重置原始数据）
		加入计算属性：
			<li v-for="n in evenNumbers">{{ n }}</li>
			
			data: {
			  numbers: [ 1, 2, 3, 4, 5 ]
			},
			computed: {
			  evenNumbers: function () {
			    return this.numbers.filter(function (number) {
			      return number % 2 === 0
			    })
			  }
			}
		计算属性不适用时
			<li v-for="n in even(numbers)">{{ n }}</li>
			
			data: {
			  numbers: [ 1, 2, 3, 4, 5 ]
			},
			methods: {
			  even: function (numbers) {
			    return numbers.filter(function (number) {
			      return number % 2 === 0
			    })
			  }
			}

事件监听
	简单实例
		<div id="example-1">
		  <button v-on:click="counter += 1">增加 1</button>
		  <p>这个按钮被点击了 {{ counter }} 次。</p>
		</div>
		
		var example1 = new Vue({
		  el: '#example-1',
		  data: {
		    counter: 0
		  }
		})
	调用方法处理监听事件
		<div id="example-2">
		  <button v-on:click="greet">Greet</button>
		</div>

		var example2 = new Vue({
		  el: '#example-2',
		  data: {
		    name: 'Vue.js'
		  },
		  methods: {
		    greet: function (event) {
		      alert('Hello ' + this.name + '!')
		      if (event) {
		        alert(event.target.tagName)
		      }
		    }
		  }
		})
	内联处理器方法
		<div id="example-3">
		  <button v-on:click="say('hi')">Say hi</button>
		  <button v-on:click="say('what')">Say what</button>
		</div>
		
		new Vue({
		  el: '#example-3',
		  methods: {
		    say: function (message) {
		      alert(message)
		    }
		  }
		})

		需要在内联语句处理器中访问原生 DOM 事件
		可以用特殊变量 $event 把它传入方法：
			<button v-on:click="warn('Form cannot be submitted yet.', $event)">
			  Submit
			</button>
			// ...
			methods: {
			  warn: function (message, event) {
			    // 现在我们可以访问原生事件对象
			    if (event) event.preventDefault()
			    alert(message)
			  }
			}
	事件修饰符
		阻止单击事件冒泡
		<a v-on:click.stop="doThis"></a>
		提交事件不再重载页面
		<form v-on:submit.prevent="onSubmit"></form>
		修饰符可以串联 
		<a v-on:click.stop.prevent="doThat"></a>
		只有修饰符
		<form v-on:submit.prevent></form>
		添加事件侦听器时使用事件捕获模式
		<div v-on:click.capture="doThis">...</div>
		只当事件在该元素本身（比如不是子元素）触发时触发回调
		<div v-on:click.self="doThat">...</div>
		点击事件将只会触发一次
		<a v-on:click.once="doThis"></a>
		注：使用修饰符时，顺序很重要
			@click.prevent.self 会阻止所有的点击
			@click.self.prevent 只会阻止元素上的点击
	键值修饰符
		只有在 keyCode 是 13 时调用 vm.submit()
		<input v-on:keyup.13="submit">
		<input v-on:keyup.enter="submit">
		<input @keyup.enter="submit">
		全部的按键别名：
			.enter
			.tab
			.delete (捕获 “删除” 和 “退格” 键)
			.esc
			.space
			.up
			.down
			.left
			.right
		自定义键值修饰符别名：
			// 可以使用 v-on:keyup.f1
			Vue.config.keyCodes.f1 = 112
	修饰键
		开启监听鼠标或键盘事件
		.ctrl
		.alt
		.shift
		.meta（Windows系统键盘meta对应windows菜单键）
		<!-- Alt + C -->
		<input @keyup.alt.67="clear">
		<!-- Ctrl + Click -->
		<div @click.ctrl="doSomething">Do something</div>
		注：修饰键和 keyup 事件一起用时，事件引发时必须按下正常的按键，两者一起按
		滑鼠按键修饰符
			.left
			.right
			.middle

表单控件绑定
	v-model 指令在表单控件元素上创建双向数据绑定
	文本
		<input v-model="message" placeholder="edit me">
		<textarea v-model="message" placeholder="add multiple lines"></textarea>
		<p>Message is: {{ message }}</p>
	复选框（单个）
		<input type="checkbox" id="checkbox" v-model="checked">
		<label for="checkbox">{{ checked }}</label>
	多个勾选框，绑定到同一个数组：
		<input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
		<label for="jack">Jack</label>
		<input type="checkbox" id="john" value="John" v-model="checkedNames">
		<label for="john">John</label>
		<input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
		<label for="mike">Mike</label>
		<br>
		<span>Checked names: {{ checkedNames }}</span>
		
		new Vue({
		  el: '...',
		  data: {
		    checkedNames: []
		  }
		})
	单选按钮
		<div id="example-4">
		  <input type="radio" id="one" value="One" v-model="picked">
		  <label for="one">One</label>
		  <br>
		  <input type="radio" id="two" value="Two" v-model="picked">
		  <label for="two">Two</label>
		  <br>
		  <span>Picked: {{ picked }}</span>
		</div>
		
		new Vue({
		  el: '#example-4',
		  data: {
		    picked: ''
		  }
		})
	单选列表:
		<div id="example-5">
		  <select v-model="selected">
		    <option disabled value="">请选择</option>
		    <option>A</option>
		    <option>B</option>
		    <option>C</option>
		  </select>
		  <span>Selected: {{ selected }}</span>
		</div>
		new Vue({
		  el: '...',
		  data: {
		    selected: ''
		  }
		})
	动态选项，用 v-for 渲染：
		<select v-model="selected">
		  <option v-for="option in options" v-bind:value="option.value">
		    {{ option.text }}
		  </option>
		</select>
		<span>Selected: {{ selected }}</span>
		
		new Vue({
		  el: '...',
		  data: {
		    selected: 'A',
		    options: [
		      { text: 'One', value: 'A' },
		      { text: 'Two', value: 'B' },
		      { text: 'Three', value: 'C' }
		    ]
		  }
		})
	注：以上 v-model 绑定是 value，显示的都是value的值
	绑定 value 到 Vue 实例的一个动态属性上（v-bind 实现）
		复选框
			<input
			  type="checkbox"
			  v-model="toggle"
			  v-bind:true-value="a"
			  v-bind:false-value="b"
			>
			// 当选中时
			vm.toggle === vm.a
			// 当没有选中时
			vm.toggle === vm.b
		单选按钮
			<input type="radio" v-model="pick" v-bind:value="a">
			// 当选中时
			vm.pick === vm.a
		选择列表设置
			<select v-model="selected">
			    <!-- 内联对象字面量 -->
			  <option v-bind:value="{ number: 123 }">123</option>
			</select>
			// 当选中时
			typeof vm.selected // -> 'object'
			vm.selected.number // -> 123
	修饰符
		.lazy
			<!-- 在 "change" 而不是 "input" 事件中更新 -->
			<input v-model.lazy="msg" >
		.number
			如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）
			<input v-model.number="age" type="number">
		.trim
			自动过滤用户输入的首尾空格
			<input v-model.trim="msg">

组件（扩展 HTML 元素，封装可重用的代码）
	注册组件
		使用Vue.component(tagName, options)，例如：
		Vue.component('my-component', {
		  // 选项
		})
		注：自定义标签名，小写，并且包含一个短杠
		<my-component></my-component> 形式使用
		在初始化根实例之前注册了组件：
			<div id="example">
			  <my-component></my-component>
			</div>
			// 注册
			Vue.component('my-component', {
			  template: '<div>A custom component!</div>'
			})
			// 创建根实例
			new Vue({
			  el: '#example'
			})
			渲染为：
			<div id="example">
			  <div>A custom component!</div>
			</div>
	局部注册（仅在另一个实例/组件的作用域中可用）
		var Child = {
		  template: '<div>A custom component!</div>'
		}
		new Vue({
		  // ...
		  components: {
		    // <my-component> 将只在父模板可用
		    'my-component': Child
		  }
		})
	当组件出现在<ul>，<ol>，<table>，<select>内时，直接使用是无效的，必须使用特殊的 is 属性：
		<table>
		  <tr is="my-row"></tr>
		</table>	
	组件中，data 必须是函数
		<div id="example-2">
		  <simple-counter></simple-counter>
		  <simple-counter></simple-counter>
		  <simple-counter></simple-counter>
		</div>

		Vue.component('simple-counter', {
		    template: '<button v-on:click="counter += 1">{{ counter }}</button>',

			data: function () {
			    return {
			      counter: 0
			    }
		    }
		})
		new Vue({
		  el: '#example-2'
		})
    构成组件
    	父组件要给子组件传递数据，子组件需要将它内部发生的事情(发送消息）告知给父组件
    	父组件-> props ->子组件
    	子组件-> events ->父组件
    Prop
    	子组件使用父组件的数据
			子组件要显式地用 props 选项声明它期待获得的数据：
			Vue.component('child', {
			  props: ['message'],
			  // 就像 data 一样，prop 可以用在模板内
			  // 同样也可以在 vm 实例中像“this.message”这样使用
			  template: '<span>{{ message }}</span>'
			})
			然后我们可以这样向它传入一个普通字符串：
			<child message="hello!"></child>

			在调用子组件：
			<bbb :m="数据"></bbb>

			子组件之内:
				props:['m','myMsg']

				props:{
					'm':String,
					'myMsg':Number
				}

		camelCase vs. kebab-case
			camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名：
			Vue.component('child', {
			  // camelCase in JavaScript
			  props: ['myMessage'],
			  template: '<span>{{ myMessage }}</span>'
			})
			<!-- kebab-case in HTML -->
			<child my-message="hello!"></child>
		动态Prop
			动态地绑定父组件的数据到子模板的 props，用 v-bind
			每当父组件的数据变化时，该变化也会传导给子组件：（两者变化同步）
			<div>
			  <input v-model="parentMsg">
			  <br>
			  <child :my-message="parentMsg"></child>
			</div>
		传递实际的 number（动态语法）
			<comp v-bind:some-prop="1"></comp>
			（错误：字面量语法）<comp some-prop="1"></comp>
	父组件获取子组件数据
		子组件把自己的数据，发送到父级
			vm.$emit(事件名,数据);
		父组件接受数据
			v-on:	@	
		例子：（注：template下面只能有一层，不能有多层标签，当有多层时得将其用div包裹）
			<template id="aaa">
				<div>//可将id="aaa"写在这个div中，留上面仅是个<template>
					<span>我是父级 -> {{msg}}</span>
					<bbb @child-msg="get"></bbb>
				</div>
			</template>
			<template id="bbb">
				<div>
					<h3>子组件-</h3>
					<input type="button" value="send" @click="send">
				</div>
			</template>

			var vm=new Vue({
				el:'#box',
				data:{
					a:'aaa'
				},
				components:{
					'aaa':{
						data(){
							return {
								msg:111,
								msg2:'我是父组件的数据'
							}
						},
						template:'#aaa',
						methods:{
							get(msg){
								// alert(msg);
								this.msg=msg;
							}
						},
						components:{
							'bbb':{
								data(){
									return {
										a:'我是子组件的数据'
									}
								},
								template:'#bbb',
								methods:{
									send(){
										this.$emit('child-msg',this.a);
									}
								}
							}
						}
					}
				}
			});
	Slot
		位置、槽口
		作用: 占个位置
		实例：
			<div id="box">
				<aaa>
					<ul slot="ul-slot">
						<li>1111</li>
						<li>2222</li>
						<li>3333</li>
					</ul>
					<ol slot="ol-slot">
						<li>111</li>
						<li>222</li>
						<li>333</li>
					</ol>
				</aaa>
				<hr>
				<aaa>
				</aaa>
			</div>
			<template id="aaa">
				<div>
					<h1>xxxx</h1>
					<slot name="ol-slot">这是默认的情况</slot>
					<p>welcome vue</p>
					<slot name="ul-slot">这是默认的情况2</slot>
				</div>
			</template>

			var vm=new Vue({
				el:'#box',
				data:{
					a:'aaa'
				},
				components:{
					'aaa':{
						template:'#aaa'
					}
				}
			});
	动态组件:
		<component :is="组件名称"></component>

响应式原理
	var vm = new Vue({
	  data:{
	  a:1
	  }
	})
	// `vm.a` 是响应的
	vm.b = 2
	// `vm.b` 是非响应的

	将响应属性添加到嵌套的对象上：
		Vue.set(vm.someObject, 'b', 2)
		this.$set(this.someObject,'b',2)
	向已有对象上添加一些属性(创建一个新的对象，让它包含原对象的属性和新的属性)
		// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`
		this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
	声明响应式属性
		Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性
		var vm = new Vue({
		  data: {
		    // 声明 message 为一个空值字符串
		    message: ''
		  },
		  template: '<div>{{ message }}</div>'
		})
		// 之后设置 `message` 
		vm.message = 'Hello!'
	异步更新队列
		<div id="example">{{message}}</div>
		var vm = new Vue({
		  el: '#example',
		  data: {
		    message: '123'
		  }
		})
		vm.message = 'new message' // 更改数据
		vm.$el.textContent === 'new message' // false
		Vue.nextTick(function () {
		  vm.$el.textContent === 'new message' // true
		})

		在组件内使用：
		Vue.component('example', {
		  template: '<span>{{ message }}</span>',
		  data: function () {
		    return {
		      message: '没有更新'
		    }
		  },
		  methods: {
		    updateMessage: function () {
		      this.message = '更新完成'
		      console.log(this.$el.textContent) // => '没有更新'
		      this.$nextTick(function () {
		        console.log(this.$el.textContent) // => '更新完成'
		      })
		    }
		  }
		})

过渡效果
	单元素/组件的过渡
		<div id="demo">
		  <button v-on:click="show = !show">
		    Toggle
		  </button>
		  <transition name="fade">
		    <p v-if="show">hello</p>
		  </transition>
		</div>

		new Vue({
		  el: '#demo',
		  data: {
		    show: true
		  }
		})

		.fade-enter-active, .fade-leave-active {
		  transition: opacity .5s
		}
		.fade-enter, .fade-leave-to /* .fade-leave-active in below version 2.1.8 */ {
		  opacity: 0
		}

		过渡的-CSS-类名
			v-enter: 
				定义进入过渡的开始状态
			v-enter-active: 
				定义过渡的状态。被用来定义过渡的过程时间，延迟和曲线函数
			v-enter-to: 
				定义进入过渡的结束状态
			v-leave: 
				定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。
			v-leave-active: 
				定义过渡的状态。被用来定义过渡的过程时间，延迟和曲线函数。
			v-leave-to: 
				定义离开过渡的结束状态。
			使用 <transition name="my-transition"> 可以重置前缀，比如 v-enter 替换为 my-transition-enter
		CSS 过渡
			<div id="example-1">
			  <button @click="show = !show">
			    Toggle render
			  </button>
			  <transition name="slide-fade">
			    <p v-if="show">hello</p>
			  </transition>
			</div>

			new Vue({
			  el: '#example-1',
			  data: {
			    show: true
			  }
			})

			/* 可以设置不同的进入和离开动画 */
			/* 设置持续时间和动画函数 */
			.slide-fade-enter-active {
			  transition: all .3s ease;
			}
			.slide-fade-leave-active {
			  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
			}
			.slide-fade-enter, .slide-fade-leave-to
			/* .slide-fade-leave-active for below version 2.1.8 */ {
			  transform: translateX(10px);
			  opacity: 0;
			}
		CSS 动画
			同 CSS 过渡，区别：v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除
			<div id="example-2">
			  <button @click="show = !show">Toggle show</button>
			  <transition name="bounce">
			    <p v-if="show">Look at me!</p>
			  </transition>
			</div>

			new Vue({
			  el: '#example-2',
			  data: {
			    show: true
			  }
			})

			.bounce-enter-active {
			  animation: bounce-in .5s;
			}
			.bounce-leave-active {
			  animation: bounce-in .5s reverse;
			}
			@keyframes bounce-in {
			  0% {
			    transform: scale(0);
			  }
			  50% {
			    transform: scale(1.5);
			  }
			  100% {
			    transform: scale(1);
			  }
			}
		自定义过渡类名
			enter-class
			enter-active-class
			enter-to-class (2.1.8+)
			leave-class
			leave-active-class
			leave-to-class (2.1.8+)

			<transition 
				name="custom-classes-transition" 
				enter-active-class="animated tada" 
				leave-active-class="animated bounceOutRight" >
 				<p v-if="show">hello</p>
			</transition>
		过渡效果持续时间
			<transition :duration="1000">...</transition>
			定制进入和移出的持续时间：
			<transition :duration="{ enter: 500, leave: 800 }">...</transition>			
		JavaScript 钩子
			<transition
			  v-on:before-enter="beforeEnter"
			  v-on:enter="enter"
			  v-on:after-enter="afterEnter"
			  v-on:enter-cancelled="enterCancelled"
			  v-on:before-leave="beforeLeave"
			  v-on:leave="leave"
			  v-on:after-leave="afterLeave"
			  v-on:leave-cancelled="leaveCancelled"
			>
			  <!-- ... -->
			</transition>
			
			methods: {
			  // --------
			  // 进入中
			  // --------
			  beforeEnter: function (el) {
			    // ...
			  },
			  // 此回调函数是可选项的设置
			  // 与 CSS 结合时使用
			  enter: function (el, done) {
			    // ...
			    done()
			  },
			  afterEnter: function (el) {
			    // ...
			  },
			  enterCancelled: function (el) {
			    // ...
			  },
			  // --------
			  // 离开时
			  // --------
			  beforeLeave: function (el) {
			    // ...
			  },
			  // 此回调函数是可选项的设置
			  // 与 CSS 结合时使用
			  leave: function (el, done) {
			    // ...
			    done()
			  },
			  afterLeave: function (el) {
			    // ...
			  },
			  // leaveCancelled 只用于 v-show 中
			  leaveCancelled: function (el) {
			    // ...
			  }
			}
			对于仅使用 JavaScript 过渡的元素添加 v-bind:css="false"，在 enter 和 leave 中，回调函数 done 是必须的 
			实例：
				<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
				<div id="example-4">
				  <button @click="show = !show">
				    Toggle
				  </button>
				  <transition
				    v-on:before-enter="beforeEnter"
				    v-on:enter="enter"
				    v-on:leave="leave"
				    v-bind:css="false"
				  >
				    <p v-if="show">
				      Demo
				    </p>
				  </transition>
				</div>

				new Vue({
				  el: '#example-4',
				  data: {
				    show: false
				  },
				  methods: {
				    beforeEnter: function (el) {
				      el.style.opacity = 0
				      el.style.transformOrigin = 'left'
				    },
				    enter: function (el, done) {
				      Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 })
				      Velocity(el, { fontSize: '1em' }, { complete: done })
				    },
				    leave: function (el, done) {
				      Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 })
				      Velocity(el, { rotateZ: '100deg' }, { loop: 2 })
				      Velocity(el, {
				        rotateZ: '45deg',
				        translateY: '30px',
				        translateX: '30px',
				        opacity: 0
				      }, { complete: done })
				    }
				  }
				})
    初始渲染的过渡
			appear 设置节点的在初始渲染的过渡
			<transition appear>
			  <!-- ... -->
			</transition>
			可以自定义 CSS 类名
			<transition
			  appear
			  appear-class="custom-appear-class"
			  appear-to-class="custom-appear-to-class" (2.1.8+)
			  appear-active-class="custom-appear-active-class"
			>
			  <!-- ... -->
			</transition>
			自定义 JavaScript 钩子：
			<transition
			  appear
			  v-on:before-appear="customBeforeAppearHook"
			  v-on:appear="customAppearHook"
			  v-on:after-appear="customAfterAppearHook"
			  v-on:appear-cancelled="customAppearCancelledHook"
			>
			  <!-- ... -->
			</transition>
	多余个元素的过渡
			<transition>
			  <table v-if="items.length > 0">
			    <!-- ... -->
			  </table>
			  <p v-else>Sorry, no items found.</p>
			</transition>
			最好给在 <transition> 组件中的多个元素设置 key
			<transition>
			  <button v-if="isEditing" key="save">
			    Save
			  </button>
			  <button v-else key="edit">
			    Edit
			  </button>
			</transition>
			等价于
			<transition>
			  <button v-bind:key="isEditing">
			    {{ isEditing ? 'Save' : 'Edit' }}
			  </button>
			</transition>
			使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡
			<transition>
			  <button v-if="docState === 'saved'" key="saved">
			    Edit
			  </button>
			  <button v-if="docState === 'edited'" key="edited">
			    Save
			  </button>
			  <button v-if="docState === 'editing'" key="editing">
			    Cancel
			  </button>
			</transition>
			等价于
			<transition>
			  <button v-bind:key="docState">
			    {{ buttonMessage }}
			  </button>
			</transition>
			 
			computed: {
			  buttonMessage: function () {
			    switch (this.docState) {
			      case 'saved': return 'Edit'
			      case 'edited': return 'Save'
			      case 'editing': return 'Cancel'
			    }
			  }
			}
	过渡模式
			in-out: 新元素先进行过渡，完成之后当前元素过渡离开
			out-in: 当前元素先进行过渡，完成之后新元素过渡进入
			<transition name="fade" mode="out-in">
			  <!-- ... the buttons ... -->
			</transition>
	多个组件的过渡
        使用动态组件:
		<transition name="component-fade" mode="out-in">
		  <component v-bind:is="view"></component>
		</transition>

		new Vue({
		  el: '#transition-components-demo',
		  data: {
		    view: 'v-a'
		  },
		  components: {
		    'v-a': {
		      template: '<div>Component A</div>'
		    },
		    'v-b': {
		      template: '<div>Component B</div>'
		    }
		  }
		})

		.component-fade-enter-active, .component-fade-leave-active {
		  transition: opacity .3s ease;
		}
		.component-fade-enter, .component-fade-leave-to {
		  opacity: 0;
		}
	列表过渡（使用 <transition-group> 组件）
		注：内部元素 总是需要 提供唯一的 key 属性值。以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag 特性更换为其他元素。
		列表的进入和离开过渡
			<transition-group name="flip-list" tag="ul">
			    <li v-for="item in items" v-bind:key="item">
			      {{ item }}
			    </li>
			  </transition-group>
		列表的位移过渡（v-move 改变定位）
			可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。
			实例：
				<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
				<div id="flip-list-demo" class="demo">
				  <button v-on:click="shuffle">Shuffle</button>
				  <transition-group name="flip-list" tag="ul">
				    <li v-for="item in items" v-bind:key="item">
				      {{ item }}
				    </li>
				  </transition-group>
				</div>

				new Vue({
				  el: '#flip-list-demo',
				  data: {
				    items: [1,2,3,4,5,6,7,8,9]
				  },
				  methods: {
				    shuffle: function () {
				      this.items = _.shuffle(this.items)
				    }
				  }
				})

				.flip-list-move {
				  transition: transform 1s;
				}
			结合以上两点的一个例子（数字移动增删）：
				<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
				<div id="list-complete-demo" class="demo">
				  <button v-on:click="shuffle">Shuffle</button>
				  <button v-on:click="add">Add</button>
				  <button v-on:click="remove">Remove</button>
				  <transition-group name="list-complete" tag="p">
				    <span
				      v-for="item in items"
				      v-bind:key="item"
				      class="list-complete-item"
				    >
				      {{ item }}
				    </span>
				  </transition-group>
				</div>

				new Vue({
				  el: '#list-complete-demo',
				  data: {
				    items: [1,2,3,4,5,6,7,8,9],
				    nextNum: 10
				  },
				  methods: {
				    randomIndex: function () {
				      return Math.floor(Math.random() * this.items.length)
				    },
				    add: function () {
				      this.items.splice(this.randomIndex(), 0, this.nextNum++)
				    },
				    remove: function () {
				      this.items.splice(this.randomIndex(), 1)
				    },
				    shuffle: function () {
				      this.items = _.shuffle(this.items)
				    }
				  }
				})

				.list-complete-item {
				  transition: all 1s;
				  display: inline-block;
				  margin-right: 10px;
				}
				.list-complete-enter, .list-complete-leave-to {
				  opacity: 0;
				  transform: translateY(30px);
				}
				.list-complete-leave-active {
				  position: absolute;
				}
			多维网格的过渡
				<div id="sudoku-demo" class="demo">
				  <h1>Lazy Sudoku</h1>
				  <p>Keep hitting the shuffle button until you win.</p>

				  <button @click="shuffle">
				    Shuffle
				  </button>
				  <transition-group name="cell" tag="div" class="container">
				    <div v-for="cell in cells" :key="cell.id" class="cell">
				      {{ cell.number }}
				    </div>
				  </transition-group>
				</div>

				new Vue({
				  el: '#sudoku-demo',
				  data: {
				    cells: Array.apply(null, { length: 81 })
				    	.map(function (_, index) { 
				      	return {
				        	id: index,
				        	number: index % 9 + 1
				        }
				      })
				  },
				  methods: {
				  	shuffle: function () {
				    	this.cells = _.shuffle(this.cells)
				    }
				  }
				})

				.container {
				  display: flex;
				  flex-wrap: wrap;
				  width: 238px;
				  margin-top: 10px;
				}
				.cell {
				  display: flex;
				  justify-content: space-around;
				  align-items: center;
				  width: 25px;
				  height: 25px;
				  border: 1px solid #aaa;
				  margin-right: -1px;
				  margin-bottom: -1px;
				}
				.cell:nth-child(3n) {
				  margin-right: 0;
				}
				.cell:nth-child(27n) {
				  margin-bottom: 0;
				}
				.cell-move {
				  transition: transform 1s;
				}
		列表的渐进过渡（通过 data 属性与 JavaScript 通信)
			<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
			<div id="staggered-list-demo">
			  <input v-model="query">
			  <transition-group
			    name="staggered-fade"
			    tag="ul"
			    v-bind:css="false"
			    v-on:before-enter="beforeEnter"
			    v-on:enter="enter"
			    v-on:leave="leave"
			  >
			    <li
			      v-for="(item, index) in computedList"
			      v-bind:key="item.msg"
			      v-bind:data-index="index"
			    >{{ item.msg }}</li>
			  </transition-group>
			</div>

			new Vue({
			  el: '#staggered-list-demo',
			  data: {
			    query: '',
			    list: [
			      { msg: 'Bruce Lee' },
			      { msg: 'Jackie Chan' },
			      { msg: 'Chuck Norris' },
			      { msg: 'Jet Li' },
			      { msg: 'Kung Fury' }
			    ]
			  },
			  computed: {
			    computedList: function () {
			      var vm = this
			      return this.list.filter(function (item) {
			        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
			      })
			    }
			  },
			  methods: {
			    beforeEnter: function (el) {
			      el.style.opacity = 0
			      el.style.height = 0
			    },
			    enter: function (el, done) {
			      var delay = el.dataset.index * 150
			      setTimeout(function () {
			        Velocity(
			          el,
			          { opacity: 1, height: '1.6em' },
			          { complete: done }
			        )
			      }, delay)
			    },
			    leave: function (el, done) {
			      var delay = el.dataset.index * 150
			      setTimeout(function () {
			        Velocity(
			          el,
			          { opacity: 0, height: 0 },
			          { complete: done }
			        )
			      }, delay)
			    }
			  }
			})
	可复用的过渡
		将 <transition> 或者 <transition-group> 作为根组件，然后将任何子组件放置在其中
		Vue.component('my-special-transition', {
		  template: '\
		    <transition\
		      name="very-special-transition"\
		      mode="out-in"\
		      v-on:before-enter="beforeEnter"\
		      v-on:after-enter="afterEnter"\
		    >\
		      <slot></slot>\
		    </transition>\
		  ',
		  methods: {
		    beforeEnter: function (el) {
		      // ...
		    },
		    afterEnter: function (el) {
		      // ...
		    }
		  }
		})
		函数组件更适合完成这个任务：
		Vue.component('my-special-transition', {
		  functional: true,
		  render: function (createElement, context) {
		    var data = {
		      props: {
		        name: 'very-special-transition',
		        mode: 'out-in'
		      },
		      on: {
		        beforeEnter: function (el) {
		          // ...
		        },
		        afterEnter: function (el) {
		          // ...
		        }
		      }
		    }
		    return createElement('transition', data, context.children)
		  }
		})
	动态过渡
		通过 name 特性来绑定动态值
			<transition v-bind:name="transitionName">
			  <!-- ... -->
			</transition>
		 CSS 过渡/动画 在不同过渡间切换
			<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
			<div id="dynamic-fade-demo">
			  Fade In: <input type="range" v-model="fadeInDuration" min="0" v-bind:max="maxFadeDuration">
			  Fade Out: <input type="range" v-model="fadeOutDuration" min="0" v-bind:max="maxFadeDuration">
			  <transition
			    v-bind:css="false"
			    v-on:before-enter="beforeEnter"
			    v-on:enter="enter"
			    v-on:leave="leave"
			  >
			    <p v-if="show">hello</p>
			  </transition>
			  <button v-on:click="stop = true">Stop it!</button>
			</div>

			new Vue({
			  el: '#dynamic-fade-demo',
			  data: {
			    show: true,
			    fadeInDuration: 1000,
			    fadeOutDuration: 1000,
			    maxFadeDuration: 1500,
			    stop: false
			  },
			  mounted: function () {
			    this.show = false
			  },
			  methods: {
			    beforeEnter: function (el) {
			      el.style.opacity = 0
			    },
			    enter: function (el, done) {
			      var vm = this
			      Velocity(el,
			        { opacity: 1 },
			        {
			          duration: this.fadeInDuration,
			          complete: function () {
			            done()
			            if (!vm.stop) vm.show = false
			          }
			        }
			      )
			    },
			    leave: function (el, done) {
			      var vm = this
			      Velocity(el,
			        { opacity: 0 },
			        {
			          duration: this.fadeOutDuration,
			          complete: function () {
			            done()
			            vm.show = true
			          }
			        }
			      )
			    }
			  }
			})

过渡状态（很高能，具体见官网）

router路由
安装：<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
	简单的例子
		<div id="app">
		  <h1>Hello App!</h1>
		  <p>
		    <!-- <router-link to="/"> 默认会被渲染成一个 `<a>` 标签 -->
		    <router-link to="/foo">Go to Foo</router-link>
		    <router-link to="/bar">Go to Bar</router-link>
		  </p>
		  <!-- 路由匹配到的组件将渲染在这里 内容展示的地方 -->
		  <router-view></router-view>
		</div>
		// 1. 定义（路由）组件（展示的内容）。可以从其他文件 import 进来
		const Foo = { template: '<div>foo</div>' }
		const Bar = { template: '<div>bar</div>' }

		// 2. 定义路由。每个路由应该映射一个组件（关联）。 其中"component" 可以是通过 Vue.extend() 创建的组件构造器
		const routes = [
		  { path: '/foo', component: Foo },
		  { path: '/bar', component: Bar }
		]
		// 3. 创建 router 实例，然后传 `routes` 配置
		const router = new VueRouter({
		  routes // （缩写）相当于 routes: routes
		})

		// 4. 创建和挂载根实例（根组件），直接启动router
		// 记得要通过 router 配置参数注入路由，
		const app = new Vue({
		  router
		}).$mount('#app')
		注：路由匹配成功，将自动设置 class 属性值 .router-link-active，可通过该属性设置一定的样式
	路由其他信息
		{{$route.params | json}}	->  当前参数
		{{$route.path}}	->  当前路径
		{{$route.query | json}}	->  数据
	动态路由
		<div id="app">
		  <p>
		    <router-link to="/user/foo">/user/foo</router-link>
		    <router-link to="/user/bar">/user/bar</router-link>
		  </p>
		  <router-view></router-view>
		</div>

		const User = {
		  template: `<div>User {{ $route.params.id }}</div>`
		}

		const router = new VueRouter({
		  routes: [
		    { path: '/user/:id', component: User }
		  ]
		})

		const app = new Vue({ router }).$mount('#app')
	嵌套路由
		<div id="box">
			<ul>
				<li>
					<router-link to="/home">主页</router-link>
				</li>
				<li>
					<router-link to="/news">新闻</router-link>
				</li>
			</ul>
			<div>
				<router-view></router-view>
			</div>	
		</div>

		<template id="home">
			<div>
				<h3>我是主页</h3>
				<div>
					<router-link to="/home/login">登录</router-link>
					<router-link to="/home/reg">注册</router-link>
				</div>
				<router-view></router-view>
			</div>
		</template>
		<template id="news">
				<h3>我是新闻</h3>
		</template>
	
		const router = new VueRouter({
		  routes: [
		    {   path: '/home', component: {
					template:'#home'
				} ,
		    	children: [
		    		{	path: '/home/login', component:{
							template:'<strong>登录信息</strong>'
						}
					},
					{	path: '/home/reg', component:{
							template:'<strong>注册信息</strong>'
						}
					}
		    	]
			},
		  	{   path: '/news', component: {
					template:'#news'
				}  
			}
		  ]
		})

		const app = new Vue({
		  router
		}).$mount('#box')
	编程式的导航
		router.push(location)
			// 字符串
			router.push('home')
			// 对象
			router.push({ path: 'home' })
			// 命名的路由
			router.push({ name: 'user', params: { userId: 123 }})
			// 带查询参数，变成 /register?plan=private
			router.push({ path: 'register', query: { plan: 'private' }})
		router.replace(location)—— 替换掉当前的 history 记录
		router.go(n) 在 history 记录中向前或者后退多少步，类似 window.history.go(n)
			// 在浏览器记录中前进一步，等同于 history.forward()
			router.go(1)
			// 后退一步记录，等同于 history.back()
			router.go(-1)
			// 前进 3 步记录
			router.go(3)
			// 如果 history 记录不够用，那就默默地失败呗
			router.go(-100)
			router.go(100)
	命名路由
		const router = new VueRouter({
		  routes: [
		    {
		      path: '/user/:userId',
		      name: 'user',
		      component: User
		    }
		  ]
		})

		<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>
		等价于router.push({ name: 'user', params: { userId: 123 }})
	命名视图
		<router-view class="view one"></router-view>
		<router-view class="view two" name="a"></router-view>
		<router-view class="view three" name="b"></router-view>

		const router = new VueRouter({
		  routes: [
		    {
		      path: '/',
		      components: {
		        default: Foo,
		        a: Bar,
		        b: Baz
		      }
		    }
		  ]
		})
	重定向
		从 /a 重定向到 /b：
		const router = new VueRouter({
		  routes: [
		    { path: '/a', redirect: '/b' }
		  ]
		})

		const router = new VueRouter({
		  routes: [
		    { path: '/a', redirect: { name: 'foo' }}
		  ]
		})

		const router = new VueRouter({
		  routes: [
		    { path: '/a', redirect: to => {
		      // 方法接收 目标路由 作为参数
		      // return 重定向的 字符串路径/路径对象
		    }}
		  ]
		})
	别名
		const router = new VueRouter({
		  routes: [
		    { path: '/a', component: A, alias: '/b' }
		  ]
		})

vuex 
安装：<script src="https://unpkg.com/vuex@2.0.0"></script>
	最简单的 Store
		const store = new Vuex.Store({
		  state: {
		    count: 0
		  },
		  mutations: {
		    increment (state) {
		      state.count++
		    }
		  }
		})
		store.commit('increment')
		console.log(store.state.count) // -> 1
		注：可通过 store.state 来获取状态对象
			通过 store.commit 方法触发状态变更
			我们是通过提交 mutation 的方式，而非直接改变 store.state.count
	简单计数实例
		<div id="app">
		  <p>{{ count }}</p>
		  <p>
		    <button @click="increment">+</button>
		    <button @click="decrement">-</button>
		  </p>
		</div>

		const store = new Vuex.Store({
		  state: {
		    count: 0
		  },
		  mutations: {
		  	increment: state => state.count++,
		    decrement: state => state.count--
		  }
		})

		new Vue({
		  el: '#app',
		  computed: {
		    count () {
			    return store.state.count
		    }
		  },
		  methods: {
		    increment () {
		      store.commit('increment')
		    },
		    decrement () {
		    	store.commit('decrement')
		    }
		  }
		})
	State
		Vuex 使用 单一状态树 ，每个应用将仅仅包含一个 store 实例
		在 Vue 组件中获得 Vuex 状态（在计算属性中返回某个状态）
			const Counter = {
			  template: `<div>{{ count }}</div>`,
			  computed: {
			    count () {
			      return store.state.count
			    }
			  }
			}
		将状态从根组件『注入』到每一个子组件中
			const app = new Vue({
			  el: '#app',
			  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
			  store,
			  components: { Counter },
			  template: '
			    <div class="app">
			      <counter></counter>
			    </div>
			  '
			})
			子组件：
			const Counter = {
			  template: `<div>{{ count }}</div>`,
			  computed: {
			    count () {
			      return this.$store.state.count
			    }
			  }
			}
			通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到
		mapState 辅助函数(当一个组件需要获取多个状态时候)
			// 在单独构建的版本中辅助函数为 Vuex.mapState
			import { mapState } from 'vuex'

			export default {
			  // ...
			  computed: mapState({
			    // 箭头函数可使代码更简练
			    count: state => state.count,

			    // 传字符串参数 'count' 等同于 `state => state.count`
			    countAlias: 'count',

			    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
			    countPlusLocalState (state) {
			      return state.count + this.localCount
			    }
			  })
			}
			或：（当映射的计算属性的名称与 state 的子节点名称相同时）
			computed: mapState([
			  // 映射 this.count 为 store.state.count
			  'count'
			])
		对象展开运算符
			computed: {
			  localComputed () { /* ... */ },
			  // 使用对象展开运算符将此对象混入到外部对象中
			  ...mapState({
			    // ...
			  })
			}
	Getters（ store 的计算属性）
		从 store 中的 state 中派生出一些状态
		例如对列表进行过滤并计数：
		computed: {
		  doneTodosCount () {
		    return this.$store.state.todos.filter(todo => todo.done).length
		  }
		}	
		有多个组件需要用到此属性：
			Getters 接受 state 作为其第一个参数：
			const store = new Vuex.Store({
			  state: {
			    todos: [
			      { id: 1, text: '...', done: true },
			      { id: 2, text: '...', done: false }
			    ]
			  },
			  getters: {
			    doneTodos: state => {
			      return state.todos.filter(todo => todo.done)
			    }
			  }
			})
			Getters 会暴露为 store.getters 对象：
			store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]
			Getters 也可以接受其他 getters 作为第二个参数：
			getters: {
			  // ...
			  doneTodosCount: (state, getters) => {
			    return getters.doneTodos.length
			  }
			}
			store.getters.doneTodosCount // -> 1

			我们可以很容易地在任何组件中使用它：
			computed: {
			  doneTodosCount () {
			    return this.$store.getters.doneTodosCount
			  }
			}
		mapGetters 辅助函数（将 store 中的 getters 映射到局部计算属性）
			import { mapGetters } from 'vuex'
			export default {
			  // ...
			  computed: {
			  // 使用对象展开运算符将 getters 混入 computed 对象中
			    ...mapGetters([
			      'doneTodosCount',
			      'anotherGetter',
			      // ...
			    ])
			  }
			}

			如果你想将一个 getter 属性另取一个名字，使用对象形式：
				mapGetters({
				  // 映射 this.doneCount 为 store.getters.doneTodosCount
				  doneCount: 'doneTodosCount'
				})
	Mutations（更改 Vuex 的 store 中的状态的唯一方法是提交 mutation）
		每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)
		回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：
			const store = new Vuex.Store({
			  state: {
			    count: 1
			  },
			  mutations: {
			    increment (state) {
			      // 变更状态
			      state.count++
			    }
			  }
			})
		以相应的 type 调用 store.commit 方法：
			store.commit('increment')
		提交载荷（Payload）
			你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）：
			// ...
			mutations: {
			  increment (state, n) {
			    state.count += n
			  }
			}
			store.commit('increment', 10)

			在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：
			// ...
			mutations: {
			  increment (state, payload) {
			    state.count += payload.amount
			  }
			}
			store.commit('increment', {
			  amount: 10
			})
		对象风格的提交方式
			提交 mutation 的另一种方式是直接使用包含 type 属性的对象：
				store.commit({
				  type: 'increment',
				  amount: 10
				})

			此时handler 保持不变：
				mutations: {
				  increment (state, payload) {
				    state.count += payload.amount
				  }
				}
		Mutations 需遵守 Vue 的响应规则
			提前在你的 store 中初始化好所有所需属性。
			当需要在对象上添加新属性时，你应该
				使用 Vue.set(obj, 'newProp', 123), 或者 -
				以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：
					state.obj = { ...state.obj, newProp: 123 }
		使用常量替代 Mutation 事件类型
			// mutation-types.js
			export const SOME_MUTATION = 'SOME_MUTATION'
			// store.js
			import Vuex from 'vuex'
			import { SOME_MUTATION } from './mutation-types'

			const store = new Vuex.Store({
			  state: { ... },
			  mutations: {
			    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名
			    [SOME_MUTATION] (state) {
			      // mutate state
			    }
			  }
			})
		mutation 必须是同步函数
		在组件中提交 Mutations
			你可以在组件中使用 this.$store.commit('xxx') 提交 mutation
			或 使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）
				import { mapMutations } from 'vuex'
				export default {
				  // ...
				  methods: {
				    ...mapMutations([
				      'increment' // 映射 this.increment() 为 this.$store.commit('increment')
				    ]),
				    ...mapMutations({
				      add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')
				    })
				  }
				}
		mutation 都是同步事务：
			store.commit('increment')
			// 任何由 "increment" 导致的状态变更都应该在此刻完成。
	Actions
		Action 提交的是 mutation，而不是直接变更状态。
		Action 可以包含任意异步操作。
		简单的 action：
			const store = new Vuex.Store({
			  state: {
			    count: 0
			  },
			  mutations: {
			    increment (state) {
			      state.count++
			    }
			  },
			  actions: {
			    //context 对象:与 store 实例具有相同方法和属性
			    //可通过 context.state 和 context.getters 来获取 state 和 getters
			    increment (context) {
			      context.commit('increment')
			    }
			  }
			})

			简化的代码：
				actions: {
				  increment ({ commit }) {
				    commit('increment')
				  }
				}
		分发 Action
			store.dispatch('increment')//触发Action
			可在 action 内部执行异步操作：
				actions: {
				  incrementAsync ({ commit }) {
				    setTimeout(() => {
				      commit('increment')
				    }, 1000)
				  }
				}
			// 以载荷形式分发
			store.dispatch('incrementAsync', {
			  amount: 10
			})

			// 以对象形式分发
			store.dispatch({
			  type: 'incrementAsync',
			  amount: 10
			})
		在组件中分发 Action
			你在组件中使用 this.$store.dispatch('xxx') 分发 action
			或 使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：
				import { mapActions } from 'vuex'
				export default {
				  // ...
				  methods: {
				    ...mapActions([
				      'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')
				    ]),
				    ...mapActions({
				      add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')
				    })
				  }
				}
		组合 Actions（不懂）
			首先，你需要明白 store.dispatch 可以处理被触发的action的回调函数返回的Promise，并且store.dispatch仍旧返回Promise：
			actions: {
			  actionA ({ commit }) {
			    return new Promise((resolve, reject) => {
			      setTimeout(() => {
			        commit('someMutation')
			        resolve()
			      }, 1000)
			    })
			  }
			}

			store.dispatch('actionA').then(() => {
			  // ...
			})

			在另外一个 action 中也可以：
			actions: {
			  // ...
			  actionB ({ dispatch, commit }) {
			    return dispatch('actionA').then(() => {
			      commit('someOtherMutation')
			    })
			  }
			}
		组合 action：
			// 假设 getData() 和 getOtherData() 返回的是 Promise
			actions: {
			  async actionA ({ commit }) {
			    commit('gotData', await getData())
			  },
			  async actionB ({ dispatch, commit }) {
			    await dispatch('actionA') // 等待 actionA 完成
			    commit('gotOtherData', await getOtherData())
			  }
			}
	Modules（模块）
		每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：
			const moduleA = {
			  state: { ... },
			  mutations: { ... },
			  actions: { ... },
			  getters: { ... }
			}

			const moduleB = {
			  state: { ... },
			  mutations: { ... },
			  actions: { ... }
			}

			const store = new Vuex.Store({
			  modules: {
			    a: moduleA,
			    b: moduleB
			  }
			})

			store.state.a // -> moduleA 的状态
			store.state.b // -> moduleB 的状态
		模块的局部状态
			对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。
				const moduleA = {
				  state: { count: 0 },
				  mutations: {
				    increment (state) {
				      // 这里的 `state` 对象是模块的局部状态
				      state.count++
				    }
				  },

				  getters: {
				    doubleCount (state) {
				      return state.count * 2
				    }
				  }
				}
			模块内部的 action，局部状态通过 context.state 暴露出来， 根节点状态则为 context.rootState：
				const moduleA = {
				  // ...
				  actions: {
				    incrementIfOddOnRootSum ({ state, commit, rootState }) {
				      if ((state.count + rootState.count) % 2 === 1) {
				        commit('increment')
				      }
				    }
				  }
				}
			对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：
				const moduleA = {
				  // ...
				  getters: {
				    sumWithRootCount (state, getters, rootState) {
				      return state.count + rootState.count
				    }
				  }
				}
		命名空间
			有自己的命名空间，可以消除不能重名的问题
			添加 namespaced: true 的方式使其成为命名空间模块
				const store = new Vuex.Store({
				  modules: {
				    account: {
				      namespaced: true,
				      // 模块内容（module assets）
				      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
				      getters: {
				        isAdmin () { ... } // -> getters['account/isAdmin']
				      },
				      actions: {
				        login () { ... } // -> dispatch('account/login')
				      },
				      mutations: {
				        login () { ... } // -> commit('account/login')
				      },
				      // 嵌套模块
				      modules: {
				        // 继承父模块的命名空间
				        myPage: {
				          state: { ... },
				          getters: {
				            profile () { ... } // -> getters['account/profile']
				          }
				        },
				        // 进一步嵌套命名空间
				        posts: {
				          namespaced: true,
				          state: { ... },
				          getters: {
				            popular () { ... } // -> getters['account/posts/popular']
				          }
				        }
				      }
				    }
				  }
				})
			在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。
		在命名空间模块内访问全局内容
			使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。
			若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。

				modules: {
				  foo: {
				    namespaced: true,
				    getters: {
				      // 在这个模块的 getter 中，`getters` 被局部化了
				      // 你可以使用 getter 的第四个参数来调用 `rootGetters`
				      someGetter (state, getters, rootState, rootGetters) {
				        getters.someOtherGetter // -> 'foo/someOtherGetter'
				        rootGetters.someOtherGetter // -> 'someOtherGetter'
				      },
				      someOtherGetter: state => { ... }
				    },
				    actions: {
				      // 在这个模块中， dispatch 和 commit 也被局部化了
				      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit
				      someAction ({ dispatch, commit, getters, rootGetters }) {
				        getters.someGetter // -> 'foo/someGetter'
				        rootGetters.someGetter // -> 'someGetter'
				        dispatch('someOtherAction') // -> 'foo/someOtherAction'
				        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'
				        commit('someMutation') // -> 'foo/someMutation'
				        commit('someMutation', null, { root: true }) // -> 'someMutation'
				      },
				      someOtherAction (ctx, payload) { ... }
				    }
				  }
				}
		带命名空间的绑定函数
			简化的：
			computed: {
			//'some/nested/module'指定所属命名空间
			  ...mapState('some/nested/module', {
			    a: state => state.a,
			    b: state => state.b
			  })
			},
			methods: {
			  ...mapActions('some/nested/module', [
			    'foo',
			    'bar'
			  ])
			}
		给插件开发者的注意事项
			如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称：

			// 通过插件的参数对象得到空间名称
			// 然后返回 Vuex 插件函数
			export function createPlugin (options = {}) {
			  return function (store) {
			    // 把空间名字添加到插件模块的类型（type）中去
			    const namespace = options.namespace || ''
			    store.dispatch(namespace + 'pluginAction')
			  }
			}
		模块动态注册
			store.registerModule 方法注册模块
			// 注册模块 `myModule`
			store.registerModule('myModule', {
			  // ...
			})
			// 注册嵌套模块 `nested/myModule`
			store.registerModule(['nested', 'myModule'], {
			  // ...
			})
			之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。
		模块重用
			使用一个函数来声明模块状态（仅 2.3.0+ 支持）：
				const MyReusableModule = {
				  state () {
				    return {
				      foo: 'bar'
				    }
				  },
				  // mutation, action 和 getter 等等...
				}

Map用法:

	　　ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
	　　（1）.打印：console.log
	　　　　var data = new Map();
	　　　　//Map {}
	　　　　console.log(data);
	　　（2）.添加 set(key,value)
	　　　　data.set('a',1);
	　　　　data.set('b',2);
	　　　　data.set('c',3);
	　　　　//Map {"a" => 1, "b" => 2, "c" => 3
	　　　　console.log(data);
	　　（3）.获得: get(key)
	　　　　//1
	　　　　console.log(data.get('a'));
	　　（4）.成员个数： size
	　　　　//3
	　　　　console.log(data.size);
	　　（5）.删除：delete
	　　　　data.delete('a');
	　　　　//Map {"b" => 2, "c" => 3}
	　　　　console.log(data);
	　　（6）.查找：has
	　　　　//true
	　　　　console.log(data.has('b'));
	　　（7）.遍历：forEach
	　　　　//b=2
	　　　　//c=3
	　　　　data.forEach((value,key)=>{
	　　　　　　console.log(key+'='+value);
	　　　　});
	使用：
	　　var s = new Set();
	　　[2,3,5,4,5,2,2].map(x => s.add(x));
	　　for(let i of s){
	　　　　console.log(i);　
	　　}
	　　//2 3 5 4

数组有变异方法（增删改等）和非变异方法(合并 切割等) 
	push()//在结尾增加一条或多条数据
	pop()//删除最后一条数据
	shift()//删除第一条数据，并返回这条数据
	unshift()//在开始增加一条或多条数据，并返回数组长度
	splice()//向/从数组中添加删除项目，然后返回被删除的项目。
	sort()//对数组的元素进行排序。
	reverse()//颠倒数组中元素的顺序。
	filter()//返回条件为真的数据
	concat()//连接两个或多个数组
	slice()//从已有的数组中返回选定的元素。

item可作为一个参数传给函数
    @click="ChangeLike(item,'liked',1)"


数组的双向绑定
  Vue.set(object, key, value) ->
  this.$set(this.numbers, index, ++this.numbers[index]);

vm.$emit( event, […args] )
	参数：
		{string} event
		[...args]
	触发当前实例上的事件。附加参数都会传给监听器回调


插件
	插件导入形式
		ES6
		import vuePayKeyboard from 'vue-pay-keyboard'
		
		//  通过require 导入
		var vuePayKeyboard = require('vuePayKeyboard')
		
		// 通过use挂载
		Vue.use(vuePayKeyboard)
		
		// 或者直接导入js文件
		<script src="./dist/vue-pay-keyboard.js"></script>

	插件从定义到使用步骤
		根据需求自定义插件即编辑 xxx.vue
		相关插件的配置
			编辑 xxxController.js
				import vueNotice from './Notice.vue' // 导入组件
				const vuenotice = {
				  install (Vue, options) {
				    Vue.component(vueNotice.name, vueNotice) // vuePayKeyboard.name 组件的name属性
				  }
				}
				if (typeof window !== 'undefined' && window.Vue) {
				  window.Vue.use(vuenotice)
				}
				export default vuenotice // 导出..
			main.js 相关配置
				import xxx from './myPlugins/xxxController.js'
				Vue.use(xxx)
		此外，若插件与调用插件的组件存在数据的相互传递，则采用父子组件数据传递的方法

关于$refs $children $parent
	1）$refs
		首先你的给子组件做标记。demo ：<firstchild ref="one"></firstchild>
		然后在父组件中，通过this.$refs.one就可以访问了这个子组件了，包括访问子组件的data里面的数据，调用它的函数
	
	2）$children
	　　他返回的是一个组件集合，如果你能清楚的知道子组件的顺序，你也可以使用下标来操作；
		for(let i=0;i<this.$children.length;i++){
		    console.log(this.$children[i].msg);输出子组件的msg数据；
		}
	
	3）$parent
	   可以在子组件中使用this.$parent.属性值，或者函数 来获取父组件的数据


axios使用步骤
	先安装！
      npm install axios
	然后！
	  npm install --save axios vue-axios
	
	配置模板！
	  import Vue from 'vue'
	  import axios from 'axios'
	  import VueAxios from 'vue-axios'
	 
	  Vue.use(VueAxios, axios)

	在脚手架里面的用法！
	  Vue.axios.get(api).then((response) => {
	    console.log(response.data)
	  })
	   
	  this.axios.get(api).then((response) => {
	    console.log(response.data)
	  })
	   
	  this.$http.get(api).then((response) => {
	    console.log(response.data)
	  })
	
    本站中是直接使用  npm install --save axios






